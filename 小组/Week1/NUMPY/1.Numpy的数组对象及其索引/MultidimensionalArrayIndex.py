import numpy as np

#多维数组索引
##############################################

a = np.array([[0, 1, 2, 3, 4, 5], [10, 11, 12, 13, 14, 15], [20, 21, 22, 23, 24, 25], [30, 31, 32, 33, 34, 35], [40, 41, 42, 43, 44, 45], [50, 51, 52, 53, 54, 55]])
print("该二维数组为：")
print(a)


#注意元素下标
print("2行4列为：", end = '')
print(a[1, 3])


#赋值
a[1, 3] = 9
print("赋值后的数字为", end = '')
print(a[1, 3])

##############################################

#索引一整行
print("第2行为：", end = '')
print(a[1])

#索引一整列
#逗号右边表示第二列，左边冒号左右都为空表示从头到尾
print("第2列为：", end = '')
print(a[:, 1])

##############################################

#切片

#第1行的4,5个元素
print("第一行的第4,5个元素为：", end = '')
print(a[0, 3: 5])

#最后两行的最后两列
print("最后两行的最后两列为：")
print(a[4:, 4:])

#第三列
print("第三列为：", end = '')
print(a[:, 2])

#第3,5行的奇数列
print("第3,5行的奇数列是：")
print(a[2: 5: 2, :: 2])

#切片是引用！
#引用机制意味着，Python并没有为b分配新的空间来存储它的值，而是让b指向了a所分配的内存空间，因此，改变b会改变a的值：

#例如：
cut1 = np.array([0, 1, 2, 3, 4])
test1 = cut1[2: 4]
test1[0] = 100
print(cut1)
#此时改变切片的数据，原数组也会改变

#但这种现象在列表中不会出现
list = [0, 1, 2, 3, 4]
test2 = list[2: 4]
test2[0] = 100
print(list)

#切片
#好处：对于大数组不用大量复制多余的值，节约了空间
#缺点：可能出现一个值改变另一个值的情况
#解决办法：使用copy()产生新内存

cut2 = np.array([0, 1, 2, 3, 4])
test3 = cut2[2: 4].copy()
test3[0] = 100
print(cut2)
##############################################